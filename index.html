<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <title>Compile Card Database</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
</head>

<body>
    <div class="navbar-fixed">
        <nav>
            <div class="nav-wrapper header">
                Compile Card Database
                <ul class="right">
                    <li><a data-target="filters" class="modal-trigger"><i class="material-icons left">filter_alt</i>Filter Cards</a></li>
                    <li><a id="clear-filters"><i class="material-icons left">refresh</i>Clear Filters</a></li>
                </ul>
            </div>
        </nav>
    </div>

    <div id="filters" class="modal filter-options">
        <div class="model-content">
            <form id="filter-form">
                <div class="header">
                    Filters
                </div>
                <div class="input-field">
                    <select id="protocol-filter" multiple>
                        <option value="" disabled selected>Select Protocol</option>
                    </select>
                    <label>Protocol</label>
                </div>

                <div class="input-field">
                    <select id="value-filter" multiple>
                        <option value="" disabled selected>Select Value</option>
                    </select>
                    <label>Value</label>
                </div>

                <div class="input-field">
                    <select id="keyword-filter" multiple>
                        <option value="" disabled selected>Select Keyword</option>
                    </select>
                    <label>Keyword</label>
                </div>

                <div class="input-field">
                    <select id="sets-filter" multiple>
                        <option value="" disabled selected>Select Set</option>
                    </select>
                    <label>Set</label>
                </div>
            </form>
        </div>
        <div class="modal-footer">
            <a href="#!" class="modal-close waves-effect waves-green btn-flat">Close</a>
        </div>
    </div>

    <div class="container">
        <ul id="protocolList" class="collapsible popout"></ul>
        <div id="content"></div>
    </div>

    <script>
        // Using a set to store unique values for each category from the data to prevent hardcoding values.
        let uniqueProtocols = new Set();
        let uniqueValues = new Set();
        let uniqueKeywords = new Set();
        let uniqueSets = new Set();
        let data;

        $(document).ready(function () {
            $.getJSON('cards.json', function (response) {
                console.log("Data loaded successfully");
                // make sure the filter lists are cleared out before adding new data. 
                uniqueProtocols.clear();
                uniqueValues.clear();
                uniqueKeywords.clear();
                uniqueSets.clear();

                data = response;

                data.forEach(function (item) {
                    uniqueProtocols.add(item.protocol.trim().toLowerCase());
                    uniqueValues.add(Number(item.value));
                    if (item.keywords) {
                        Object.keys(item.keywords).forEach(function (keyword) {
                            uniqueKeywords.add(keyword.trim().toLowerCase());
                        });
                    }
                    uniqueSets.add(item.set.toLowerCase());
                });

                let protocolsArray = Array.from(uniqueProtocols);
                let valuesArray = Array.from(uniqueValues);
                let keywordsArray = Array.from(uniqueKeywords);
                let setsArray = Array.from(uniqueSets);

                setupFilters(protocolsArray, valuesArray, keywordsArray, setsArray);

                displayData(data);
                $('#protocolList').collapsible();
                $('.modal').modal();
                $('#clear-filters').on('click', function () {
                    clearFilters();
                });
            }).fail(function (jqxhr, textStatus, error) {
                console.error("Failed to load card data: " + textStatus + ", " + error);
            });
        });

        const tooltipTexts = {
            'top': 'Persistent: While this card is face-up, this passive text is never covered.',
            'middle': 'Immediate: Resolve this active text upon card play/flip/uncover.',
            'bottom': 'Auxiliary: This passive text is often, but not limited to, triggered effects, but is only viable when uncovered',
        };

        // Using a helper function to get the tooltip text based on the type in case functionality needs to be expanded later
        function getTooltipText(toolTipType) {
            return tooltipTexts[toolTipType] || '';
        }

        function setupFilters(protocols, values, keywords, sets) {
            let protocolFilter = $('#protocol-filter');
            protocols.sort().forEach(function (protocol) {
                let option = $('<option>').attr('value', protocol).text(protocol);
                protocolFilter.append(option);
            });

            let valueFilter = $('#value-filter');
            values.sort((a, b) => a - b).forEach(function (value) {
                let option = $('<option>').attr('value', value).text(value);
                valueFilter.append(option);
            });

            let keywordFilter = $('#keyword-filter');
            keywords.sort().forEach(function (keyword) {
                let option = $('<option>').attr('value', keyword).text(keyword);
                keywordFilter.append(option);
            });

            let setsFilter = $('#sets-filter');
            sets.sort().forEach(function (set) {
                let option = $('<option>').attr('value', set).text(set);
                setsFilter.append(option);
            });

            $('select').formSelect();

            $('#filter-form').on('change', function () {
                applyFilters();
            });
        }

        function applyFilters() {
            let selectedProtocols = $('#protocol-filter').val();
            let selectedValues = $('#value-filter').val();
            let selectedKeywords = $('#keyword-filter').val();
            let selectedSets = $('#sets-filter').val();

            let filteredData = data.filter(function (item) {
                let matchesProtocol = true;
                let matchesValue = true;
                let matchesKeyword = true;
                let matchesSet = true;

                if (selectedProtocols && selectedProtocols.length > 0) {
                    matchesProtocol = selectedProtocols.includes(item.protocol.toLowerCase());
                }

                if (selectedValues && selectedValues.length > 0) {
                    matchesValue = selectedValues.includes(item.value.toString());
                }

                if (selectedKeywords && selectedKeywords.length > 0) {
                    matchesKeyword = selectedKeywords.some(function (kw) {
                        return item.keywords && item.keywords[kw];
                    });
                }

                if (selectedSets && selectedSets.length > 0) {
                    matchesSet = selectedSets.includes(item.set.toLowerCase());
                }

                return matchesProtocol && matchesValue && matchesKeyword && matchesSet;
            });

            displayData(filteredData);
        }

        function clearFilters() {
            $('#protocol-filter').val(null);
            $('#value-filter').val(null);
            $('#keyword-filter').val(null);
            $('#sets-filter').val(null);
            $('select').formSelect();
            displayData(data);
        }


        function displayData(data) {
            var tooltipElements = document.querySelectorAll('.tooltipped');
            var tooltipInstances = M.Tooltip.getInstance(tooltipElements);
            if (tooltipInstances) {
                tooltipInstances.destroy();
            }

            let groupedData = groupByProtocol(data);
            let contentDiv = $('#content');
            let contentUL = $('#protocolList');

            contentDiv.empty();
            contentUL.empty();

            $.each(groupedData, function (protocol, items) {
                let protocolList = $('<li>');
                let protocolClass = sanitizeProtocolName(protocol.toLowerCase());
                let protocolHeader = $('<div>').addClass('protocol-header collapsible-header ' + protocolClass).text(protocol);

                protocolList.append(protocolHeader);

                let protocolRow = $('<div>').addClass('collapsible-body');
                let rowDiv = $('<div>').addClass('row');

                $.each(items, function (index, item) {
                    let card = createCard(item);
                    rowDiv.append(card);
                });

                protocolRow.append(rowDiv);
                protocolList.append(protocolRow);
                contentUL.append(protocolList);
            });
        }

        function groupByProtocol(data) {
            let grouped = {};
            data.forEach(function (item) {
                let protocol = item.protocol || 'Unknown';
                if (!grouped[protocol]) {
                    grouped[protocol] = [];
                }
                grouped[protocol].push(item);
            });
            return grouped;
        }

        function createCardSection(sectionData, sectionType) {
            if (sectionData && sectionData.text) {
                let emphasisText = sectionData.emphasis ? '<span class="emphasis">' + sectionData.emphasis + '</span> ' : '';
                let toolTipText = getTooltipText(sectionType);
                let section = $('<div>')
                    .addClass('card-section has-background tooltipped')
                    .attr('data-tooltip', toolTipText)
                    .html(emphasisText + sectionData.text);
                section.tooltip();
                return section;
            } else {
                let section = $('<div>')
                    .addClass('card-section blank-section')
                    .text('');
                return section;
            }
        }

        function createCard(item) {
            let colDiv = $('<div>').addClass('col');
            let protocolClass = sanitizeProtocolName(item.protocol.toLowerCase());
            let cardDiv = $('<div>').addClass('card fixed-height-card ' + protocolClass);
            let cardContentDiv = $('<div>').addClass('card-content');
            let cardTitle = $('<div>').addClass('custom-card-title');
            let protocolDiv = $('<div>').addClass('protocol').text(item.protocol);
            let valueDiv = $('<div>').addClass('value').text(item.value);

            cardTitle.append(protocolDiv).append(valueDiv);
            cardContentDiv.append(cardTitle);

            let sectionWrapper = $('<div>').addClass('section-wrapper');

            sectionWrapper.append(createCardSection(item.top, 'top'));
            sectionWrapper.append(createCardSection(item.middle, 'middle'));
            sectionWrapper.append(createCardSection(item.bottom, 'bottom'));

            cardContentDiv.append(sectionWrapper);

            let setDiv = $('<div>').addClass('set-text').text(item.set.toUpperCase() || '');
            cardContentDiv.append(setDiv);

            cardDiv.append(cardContentDiv);
            colDiv.append(cardDiv);

            return colDiv;
        }

        function sanitizeProtocolName(protocol) {
            return protocol.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
        }

    </script>
</body>

</html>